DATA 	SEGMENT		PARA	PUBLIC	'data'
	DOWN DW 0
	CMPBX DW 0 
	CMPCX DW 0
	LEFT DW 0
	NUM DW 0
	MCOLOUR DB 0
	NRCOL DW 00
	NRLIN dw 00
	COLOUR DW 0Eh
	PNT DB ?;
	
	; HERE WE HAVE THE PIXELS FROM EACH LETTER FOR STARTING SCREEN AND WINNING SCREEN MESSAGES
	LETTER_A DB 0,15,15,0, 15,0,0,15, 15,15,15,15, 15,0,0,15, 15,0,0,15;
	LETTER_C DB 0,15,15,0, 15,0,0,15, 15,0,0,0, 15,0,0,15, 0,15,15,0;
	LETTER_G DB 0,15,15,0, 15,0,0,0, 15,0,15,15, 15,0,0,15, 0,15,15,0;
	LETTER_H DB 15,0,0,15, 15,0,0,15, 15,15,15,15, 15,0,0,15, 15,0,0,15; 
	LETTER_I DB 15,15,15,0, 0,15,0,0, 0,15,0,0, 0,15,0,0, 15,15,15,0;
	LETTER_K DB 15,0,0,15, 15,0,15,0, 15,15,0,0, 15,0,15,0, 15,0,0,15;
	LETTER_L DB 15,0,0,0, 15,0,0,0, 15,0,0,0, 15,0,0,0, 15,15,15,15;
	LETTER_N DB 15,0,0,15, 15,15,0,15, 15,0,15,15, 15,0,0,15, 15,0,0,15; 
	LETTER_O DB 0,15,15,0, 15,0,0,15, 15,0,0,15, 15,0,0,15, 0,15,15,0;
	LETTER_R DB 15,15,15,0, 15,0,0,15, 15,15,15,0, 15,0,15,0, 15,0,0,15;
	LETTER_S DB 0,15,15,15, 15,0,0,0, 0,15,15,0, 0,0,0,15, 15,15,15,0;
	LETTER_T DB 15,15,15,15, 0,15,0,0, 0,15,0,0, 0,15,0,0, 0,15,0,0;
	LETTER_U DB 15,0,0,15, 15,0,0,15, 15,0,0,15, 15,0,0,15, 0,15,15,0;
	LETTER_EX DB 0,15,0,0, 0,15,0,0, 0,15,0,0, 0,0,0,0, 0,15,0,0;
	LETTER DB 0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0;
	
	;ARRAY_COLOURS HOLDS THE PIXEL COLOUR THAT WILL FILL EACH SQUARE
	ARRAY_COLOURS DB 22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22;
	;ARRAY_CHANGES WILL BE USED FOR RANDOM MAP GENERATING SEQUENCES
	ARRAY_CHANGES DB 255 DUP(0);
	
	;THESE TWO ARE USED FOR GENERATING THE MATRIX
	COLOANA DW 20;
	LINIE DW 20;
	
DATA	ENDS

;320 down
;200 left GAME_DONE

INCLUDE C:\TASM\LOUT.MAC; HERE I HAVE THE MACRO TO PRINT EACH LETTER
 
EXTRN clearScreen:FAR; MAKING THE WHOLE SCREEN BLACK
 
CODE SEGMENT PARA PUBLIC 'CODE'
ASSUME CS:CODE, DS:DATA
START PROC FAR
	PUSH DS
	XOR AX, AX
	PUSH AX
	MOV AX, DATA
	MOV DS, AX
	MOV BX,0; COLOANA
	MOV CX,0; LINIE
	
	;AH=0Ch	AL = Color, BH = Page Number, CX = x, DX = y (DL - COLOUR)
	
	MOV AH, 0   ; set display mode function.
	MOV AL, 13h ; mode 13h = 320x200 pixels, 256 colors.
	INT	10h 
	
	MOV AX,02H; HIDE CURSOR
	INT 33H;
	
; ----------------------------------- DISPLAY WELCOME MESSAGE ------------------------------	
	;PRINTING ALL THE LETTERS ONE BY ONE
	MOV CX,20; POSITION OF THE STARTING LETTER: SO IT STAYS MORE IN THE MIDDLE OF THE SCREEN
	MOV BX,45;
	PRINT_W_MESSAGE LETTER_L;
	PRINT_W_MESSAGE LETTER_I;
	PRINT_W_MESSAGE LETTER_G;
	PRINT_W_MESSAGE LETTER_H;
	PRINT_W_MESSAGE LETTER_T;
	PRINT_W_MESSAGE LETTER_S;
	PRINT_W_MESSAGE LETTER;
	PRINT_W_MESSAGE LETTER_O;
	PRINT_W_MESSAGE LETTER_U;
	PRINT_W_MESSAGE LETTER_T;
	ADD CX,40; PLACED UNDERNEATH THE LAST TEXT SHOWN
	MOV BX,20;
	PRINT_W_MESSAGE LETTER_C;
	PRINT_W_MESSAGE LETTER_L;
	PRINT_W_MESSAGE LETTER_I;
	PRINT_W_MESSAGE LETTER_C;
	PRINT_W_MESSAGE LETTER_K;
	PRINT_W_MESSAGE LETTER;
	PRINT_W_MESSAGE LETTER_R;
	PRINT_W_MESSAGE LETTER_I;
	PRINT_W_MESSAGE LETTER_G;
	PRINT_W_MESSAGE LETTER_H;
	PRINT_W_MESSAGE LETTER_T;
	PRINT_W_MESSAGE LETTER;
	PRINT_W_MESSAGE LETTER_T;
	PRINT_W_MESSAGE LETTER_O;
	PRINT_W_MESSAGE LETTER;
	PRINT_W_MESSAGE LETTER_S;
	PRINT_W_MESSAGE LETTER_T;
	PRINT_W_MESSAGE LETTER_A;
	PRINT_W_MESSAGE LETTER_R;
	PRINT_W_MESSAGE LETTER_T;
	JMP LAVE5; CHECK IF WE CLICKED RIGHT IN RODER TO START THE GAME
	
; ----------------------------------------- DISPLAY MATRIX ---------------------------------------------    

	GENER: 
	CALL GENERATE; GENERATES THE RANDOM SEQUENCE BASED ON THE ARRAY_CHANGED CREATED BY THE PSEUDO RANDOM NUMBER GENERATOR
	
	
	LAVE2: 
	MOV AX, 20;
	MOV   COLOANA, AX; WE MAKE SURE THAT COLOANA AND LINIE ARE 20 FOR THE "PRINT_MATRIX" FUNCTION
	MOV   LINIE, AX
	CALL clearScreen;
	; UNDERNEATH WE SEE IF ALL THE LIGHTS ARE OFF -> THE PLAYER WINS AND WE JUMP TO THE WINNING MESSAGE SCREEN
	MOV SI,0;
	MOV CX, 23;
	LOOPLOP:; CHECKING IF EACH LIGHT FROM THE MATRIX IS TURNED OFF
		CMP ARRAY_COLOURS[SI],22 ; 22 STANDS FOR THE LIGHT GRAY
		JNE CC;
		INC SI;
	LOOP LOOPLOP;
	JMP LAVE6
	
	CC: ; IF SOM LIGHTS ARE STILL ON, WE CONTINUE THE GAME;
	
	CALL PRINT_MATRIX;
	
	MOV AX, 0;
	MOV COLOUR,AX;
	
	
; -------------------------------------------- MOUSE IN GAME -------------------------------------------------

	LAVE3: CALL MOUSE;

; -------------------------------------------- MOUSE IDLE SCREEN -------------------------------------------------

	LAVE5: CALL MOUSSE;


; -----------------------------------CLEAR SCREEN (USED AFTER A MESSAGE)------------------------------

	LAVE4: CALL clearScreen;

; ---------------------------------------- WINNING MESSAGE --------------------------------------------

	LAVE6: CALL clearScreen; SAME AS THE OTHER TEXT, BUT WE CLEAN RHE WHOLE SCREEN BEFOREHAND
	MOV CX,20;
	MOV BX,45;
	PRINT_W_MESSAGE LETTER_C;
	PRINT_W_MESSAGE LETTER_O;
	PRINT_W_MESSAGE LETTER_N;
	PRINT_W_MESSAGE LETTER_G;
	PRINT_W_MESSAGE LETTER_R;
	PRINT_W_MESSAGE LETTER_A;
	PRINT_W_MESSAGE LETTER_T;
	PRINT_W_MESSAGE LETTER_U;
	PRINT_W_MESSAGE LETTER_L;
	PRINT_W_MESSAGE LETTER_A;
	PRINT_W_MESSAGE LETTER_T;
	PRINT_W_MESSAGE LETTER_I;
	PRINT_W_MESSAGE LETTER_O;
	PRINT_W_MESSAGE LETTER_N;
	PRINT_W_MESSAGE LETTER_S;
	PRINT_W_MESSAGE LETTER_EX;
	
	ADD CX,40;
	MOV BX,20;
	PRINT_W_MESSAGE LETTER_C;
	PRINT_W_MESSAGE LETTER_L;
	PRINT_W_MESSAGE LETTER_I;
	PRINT_W_MESSAGE LETTER_C;
	PRINT_W_MESSAGE LETTER_K;
	PRINT_W_MESSAGE LETTER;
	PRINT_W_MESSAGE LETTER_R;
	PRINT_W_MESSAGE LETTER_I;
	PRINT_W_MESSAGE LETTER_G;
	PRINT_W_MESSAGE LETTER_H;
	PRINT_W_MESSAGE LETTER_T;
	PRINT_W_MESSAGE LETTER;
	PRINT_W_MESSAGE LETTER_T;
	PRINT_W_MESSAGE LETTER_O;
	PRINT_W_MESSAGE LETTER;
	PRINT_W_MESSAGE LETTER_S;
	PRINT_W_MESSAGE LETTER_T;
	PRINT_W_MESSAGE LETTER_A;
	PRINT_W_MESSAGE LETTER_R;
	PRINT_W_MESSAGE LETTER_T;
	PRINT_W_MESSAGE LETTER;
	PRINT_W_MESSAGE LETTER_A;
	PRINT_W_MESSAGE LETTER_G;
	PRINT_W_MESSAGE LETTER_A;
	PRINT_W_MESSAGE LETTER_I;
	PRINT_W_MESSAGE LETTER_N;
	JMP LAVE5;
	
	INTERMID:
	JMP LAVE3
	
; ----------------------------------------- START PROCEDURES -----------------------------------------------

PRINT_MATRIX PROC NEAR
MOV AX,02H; HIDE CURSOR
	INT 33H;
	MOV SI,0;
	MOV AX, 0A000h ; THE OFFSET TO VIDEO MEMORY
	MOV ES, AX ; WE LOAD IT TO ES THROUGH AX BECAUSE IMMEDIATE OPERATION IS NOT ALOWED FOR ES
	MOV BX,2; COLOANA
	MOV CX,0; LINIE
	LOOPIE:
		INC BX;
		MOV AX,320; 320: LATIMEA. CX X 320 => WE CHOOSE THE LINE WE START FROM
		MUL CX;
		ADD AX,BX; HERE WE ADD THE COLUMN WE START ON
		MOV DI,AX; HERE WE GIE THE ADDRESS
		MOV DL,  ARRAY_COLOURS[SI]; CHOOSING THE COLOUR
		MOV [ES:DI],DL; PUTTING THE PIXEL
		CMP BX, COLOANA; LAST SQUARE COLUMN => NEW LINE
	JB LOOPIE;
		; AFTER WE FINISHED DRAWING A LINE OF PIXELS
		SUB BX,18; SUBTRACT 18 FROM THE COLUMN SO WE CAN START FROM THE SAME COLUMN BUT DIFFERENT LINE 
		INC CX;
		CMP CX, LINIE; LAST SQUARE COLUMN + LINE => NEW SQUARE
	JB LOOPIE;
		; AFTER WE FINISHED DRAWING A WHOLE SQUARE
		SUB CX,20;
		MOV BX, COLOANA; MOV TO BX THIS VALUE SO WE CAN START A NEW COLUMN
		ADD BX,2; SPACE BETWEEN THE SQUARES
		INC SI;
		ADD COLOANA,20; STARTING A NEW SQUARE FROM A NEW COLUMN
		CMP COLOANA, 116; WE CHECK IF IT'S THE LAST ROW FROM THE MATRIX ( WE HAVE A WHOLE ROW FINISHED. WE START A NEW ROW)
	JBE LOOPIE;
		; STARTING A NEW ROW OF SQUARES
		MOV BX,2;
		SUB COLOANA, 100; STARTING FROM "COLUMN 0"
		ADD LINIE,2; SPACE BETWEEN THE ROWS OF SQUARES
		MOV CX, LINIE; STARTING FROM THE LAST LINE WE LEFT OFF (20 IN THE 1ST OCCURANCE)
		ADD LINIE, 20; ADDING 20 SO IN THE 2ND OCCURANCE WE START FROM LINE 40 AND SO ON
		CMP LINIE,116; WE CHECK IT IT'S THE LAST LINE. LAST LINE + LAST COLUMN = MATRIX FINISHED
	JBE LOOPIE;
	JA INTERMID; INTERMID IS THERE BECAUSE OTHERWISE THE JUMP WOULD HAVE BEEN TOO LONG
PRINT_MATRIX ENDP;

MOUSE PROC NEAR; mouse for the matrix screen
	
	MOV AX, 0001H; SHOW MOUSE POINTER
	INT 33H;
	
	Next:
	mov ax, 3   ;GET CURSOR POSITION IN CX,DX
	int 33h
	
	MOV AX,02H; HIDE CURSOR
	INT 33H;
	
	call putpix ;CALL PROCEDURE THAT PUTS A PIXEL
	jmp Next

	mov ah,4ch; RETURN CODE. PROCESS TERMINATED
	int 21h
MOUSE ENDP

	
putpix proc   
	mov al, MCOLOUR   ;COLOUR OF PIXEL
	mov ah, 0ch    
	shr cx,1    ; CX WILL BE DOUBLED SO WE DIVIDE BY 2
	int 10h     ; SET PIXEL
	MOV AX, 0005h; Get Mouse Button Press Information
	MOV BX, 0H; BX = 0	left button
					;1	right button
	INT 33H;
	CMP BX,1; IF IT'S THE RIGHT BUTTON WE PROCEED. OTHERWISE WE JUMP TO RETURN. THE PROCESS UNTIL NOW WILL ONLY CHANGE THE COLOUR OF THE PIXEL TRAIL
	JNE nex;
	XCHG DX,CX;
	CALL COMPARECX; COMPARECX AND COMPAREDX WILL CHECK IF WE PRESSED A SQUARE
	CALL COMPAREDX;
	MOV SI, CX;
	ADD SI, DX; HERE WE COMPUTER WHICH SQUARE WE PRESSED.  CX- LINE DX- COLUMN;
	CALL ENGEN; GENERATE A CHANGE FOR THAT SPECIFIC SQUARE WE PRESSED. ALL THE NEIGHBOURS ALSO CHANGE
	INC MCOLOUR; INCREASE THE COLOUR OF THE MOUSE WE WILL USE IN THE NEXT ITERATION
	JMP LAVE2; WE JUMP  STRAIGHT TO PAINTING THE NEW MATRIX
	nex:
	ret
putpix endp
	
MOUSSE PROC NEAR ; MOUSE FOR A START/END SCREEN;
	MOV AX, 0001H; SHOW MOUSE POINTER
	INT 33H;
	
	Next1:
	mov ax, 3   ;get cursor positon in cx,dx
	int 33h

	call putpixe ;call procedure 
	jmp Next1

	mov ah,4ch
	int 21h
MOUSSE ENDP

putpixe proc   
	mov al, MCOLOUR   ;COLOUR OF PIXEL
	mov ah, 0ch    
	shr cx,1    ; CX WILL BE DOUBLED SO WE DIVIDE BY 2
	int 10h     ; SET PIXEL
	MOV AX, 0005h; Get Mouse Button Press Information
	MOV BX, 0H; BX = 0	left button
					;1	right button
	INT 33H;
	CMP BX,1; IF IT'S THE RIGHT BUTTON WE PROCEED. OTHERWISE WE JUMP TO RETURN. THE PROCESS UNTIL NOW WILL ONLY CHANGE THE COLOUR OF THE PIXEL TRAIL
	JNE nex1;
	INC MCOLOUR;
	nex1:
	MOV AX, 0005h; Get Mouse Button Press Information
	MOV BX, 1H; BX = 0	left button
					;1	right button
	INT 33H;
	CMP BX,1; IF WE DIDN'T PRESS THE RIGHT BUTTON , JUMP  AT THE END
	JNE nexx1;
	; HERE WE COMPUTE THE RANDOM SEQUENCE
	MOV AX,CX; IN ARRAY_CHANGE WE ADD CHANGES THAT WE WILL TRANSFORM LATER IN CHANGES IN THE MAIN MATRIX
	ADD AX,DX;
	XOR AH,AH;
	MOV SI,AX;
	ADD ARRAY_CHANGES[SI], 1;
	ADD ARRAY_CHANGES[SI+1],1;
	ADD ARRAY_CHANGES[SI+5],1;
	ADD ARRAY_CHANGES[SI-5],1;
	MOV AX, DX;
	XOR AH,AH;
	MOV SI,AX;
	;ADD ARRAY_CHANGES[SI], 1;
	;ADD ARRAY_CHANGES[SI-1], 1;
	;ADD ARRAY_CHANGES[SI+5], 1;
	MOV AL,DH;
	MOV SI,AX;
	;ADD ARRAY_CHANGES[SI], 1;
	MOV AX, CX;
	XOR AH,AH;
	MOV SI,AX;
	;ADD ARRAY_CHANGES[SI], 1;
	;ADD ARRAY_CHANGES[SI+7], 1;
	;ADD ARRAY_CHANGES[SI+10], 1;
	;ADD ARRAY_CHANGES[SI-14], 1;
	;ADD ARRAY_CHANGES[SI+5], 1;
	;ADD ARRAY_CHANGES[SI-5], 1;
	SHR AX,4;
	MOV SI,AX;
	;ADD ARRAY_CHANGES[SI], 1;
	;ADD ARRAY_CHANGES[SI+5], 1;
	MOV AL,CH;
	MOV SI,AX;
	;ADD ARRAY_CHANGES[SI], 1;
	JMP GENER;
	nexx1:
	ret
putpixe endp

	

GENERATE PROC
	MOV SI,0;
	MOV CX,25;
	LPPOI:
		MOV DI,SI;
		CMP ARRAY_CHANGES[DI],1
		JB NEXT01; 
			CALL ENGEN;
		NEXT01:; I HAVE MORE OF THOSE COMPARISIONS DUE TO THE FACT THAT THE NUMBER MIGHT JUMP AWAY FROM THE NEEDED RANGE OF 0-24
		CMP ARRAY_CHANGES[DI],1
		JB NEXT02;
			CALL ENGEN; ENGEN MAKES CHANGES TO THE MATRIX ON THE SQUARE SI
		NEXT02: ADD DI,25; WE KEEP ADDING 25 TO KEEP THE VALUE OF THE MATRIX WE WANT TO CHANGE EVEN IF WE JUMP FROM THE RANGE
		;EXAMPLE: SQUARE 0 WILL BE CHANGED BY ARRAY_CHANGES[DI] WHERE DI CAN BE 0,25,50,75 AND SO ON. SAME GOES FOR SQUARE 1: 1,26,51,76,...
		CMP ARRAY_CHANGES[DI],1
		JB NEXT03;
			CALL ENGEN;
		NEXT03: ADD DI,25
		CMP ARRAY_CHANGES[DI],1
		JB NEXT04;
			CALL ENGEN;
		NEXT04: ADD DI,25
		CMP ARRAY_CHANGES[DI],1
		JB NEXT05;
			CALL ENGEN;
		NEXT05:
		ADD DI,25
		CMP ARRAY_CHANGES[DI],1
		JB NEXT06;
			CALL ENGEN;
		NEXT06:
		ADD DI,25
		CMP ARRAY_CHANGES[DI],1
		JB NEXT07;
			CALL ENGEN;
		NEXT07:
		ADD DI,25
		CMP ARRAY_CHANGES[DI],1
		JB NEXT08;
			CALL ENGEN;
		NEXT08:
		ADD DI,25
		CMP ARRAY_CHANGES[DI],1
		JB NEXT09;
			CALL ENGEN;
		NEXT09:
		INC SI; INCREASE THE SQUARE WHERE WE WILL CHECK IF IT REMAINS UNCHANGED OR NOT
	LOOP LPPOI
	RET;
GENERATE ENDP;

ENGEN PROC; THIS FUNCTION MAINLY JUST CHANGES THE CHOSEN MATRIX FROM ON TO OFF OR OFF TO ON DEPENDING ON ITS CURRENT STATE. IT ALSO CHANGES ITS NEIGHBOURS.
	CMP ARRAY_COLOURS[SI],22; IF IT'S OFF, SUBTRACT 7 (MAKES IT FROM OFF -> ON)
	JNE PAR2;
	SUB ARRAY_COLOURS[SI],7;
	JMP PAR3;
	PAR2:
	CMP ARRAY_COLOURS[SI],15; OTHERWISE ADD 7; (MAKES IT FROM ON -> OFF)
	JNE PAR3;
	ADD ARRAY_COLOURS[SI],7;
	PAR3:
	CMP SI,4 ; HERE WE WON'T CHANGE THE UTMOST RIGHT SQUARES DUE TO THE FACT THAT I MAKE CHANGES TO A SQUARE FROM THE NEXT LINE, 1ST COLUMN
	JE  PAR5;
	CMP SI,9;
	JE PAR5;
	CMP SI,14;
	JE PAR5
	CMP SI,19;
	JE PAR5;
	CMP SI,24;
	JE PAR5; IF IT'S A SQUARE FROM UTMOST RIGHT, IGNORE THIS SET OF OPERATIONS
	CMP ARRAY_COLOURS[SI+1],22; DO THE SAME AS THE MAIN SQUARE
	JNE PAR4;
	SUB ARRAY_COLOURS[SI+1],7;
	JMP PAR5;
	PAR4:
	CMP ARRAY_COLOURS[SI+1],15
	JNE PAR5;
	ADD ARRAY_COLOURS[SI+1],7;
	PAR5:
	CMP SI,5; HERE WE WON'T CHANGE THE UTMOST LEFT SQUARES DUE TO THE FACT THAT I MAKE CHANGES TO A SQUARE FROM THE NEXT LINE, LAST COLUMN
	JE  PAR7;
	CMP SI,10;
	JE PAR7;
	CMP SI,15;
	JE PAR7
	CMP SI,20;
	JE PAR7;
	CMP SI,0;
	JE PAR7;
	CMP ARRAY_COLOURS[SI-1],22; DO THE SAME AS THE MAIN SQUARE
	JNE PAR6;
	SUB ARRAY_COLOURS[SI-1],7;
	JMP PAR7;
	PAR6:
	CMP ARRAY_COLOURS[SI-1],15
	JNE PAR7;
	ADD ARRAY_COLOURS[SI-1],7;
	PAR7:
	CMP ARRAY_COLOURS[SI-5],22; DO THE SAME AS THE MAIN SQUARE
	JNE PAR8;
	SUB ARRAY_COLOURS[SI-5],7;
	JMP PAR9;
	PAR8:
	CMP ARRAY_COLOURS[SI-5],15
	JNE PAR9;
	ADD ARRAY_COLOURS[SI-5],7;
	PAR9:
	CMP ARRAY_COLOURS[SI+5],22; DO THE SAME AS THE MAIN SQUARE
	JNE PAR10;
	SUB ARRAY_COLOURS[SI+5],7;
	JMP PAR11;
	PAR10:
	CMP ARRAY_COLOURS[SI+5],15
	JNE PAR11;
	ADD ARRAY_COLOURS[SI+5],7;
	PAR11:
	RET;
ENGEN ENDP;

COMPARECX PROC; HERE WE SIMPLY CHECK THE MOUSE POSITION FROM WHERE WE PRESS IS ON WHICH LINE. THE SPACE BETWEEN THEM IS IGNORED
; THERE ARE SOME CALCULATIONS I'VE MADE IN ORDER TO FIND THE CORRECT COORDINATES
	CMP CX, 20
	JA NEXT11
		MOV CX, 0; IF ONE SQUARE FROM THE 1ST LINE WAS PRESSED
		RET;
	NEXT11:
	CMP CX,23
	JB ENDO;
	CMP CX,43
	JA NEXT22
		MOV CX, 5; IF ONE SQUARE FROM THE 2ND LINE WAS PRESSED
		RET;
	NEXT22:
	CMP CX,45
	JB ENDO
	CMP CX,65
	JA NEXT33
		MOV CX, 10; IF ONE SQUARE FROM THE 3RD LINE WAS PRESSED
		RET;
	NEXT33:
	CMP CX,68
	JB ENDO
	CMP CX,85
	JA NEXT44
		MOV CX, 15; IF ONE SQUARE FROM THE 4TH LINE WAS PRESSED
		RET;
	NEXT44:
	CMP CX,87
	JB ENDO
	CMP CX,107
	JA ENDO
		MOV CX, 20; IF ONE SQUARE FROM THE 5TH LINE WAS PRESSED
		RET;
	ENDO:
	JMP LAVE3;
COMPARECX ENDP;
	
COMPAREDX PROC ; HERE WE CHECK THE COLUMN OF THE SQUARE WE PRESSED. IF WE PRESSED ANY SQUARE
	CMP DX,3
	JB ENDO1;
	CMP DX, 40
	JA NEXT111
		MOV DX, 0; COLUMN 0
		RET;
	NEXT111:
	CMP DX,43
	JB ENDO1;
	CMP DX,81
	JA NEXT221
		MOV DX, 1;COLUMN 1
		RET;
	NEXT221:
	CMP DX,84
	JB ENDO1
	CMP DX,120
	JA NEXT331
		MOV DX, 2;COLUMN 2
		RET;
	NEXT331:
	CMP DX,124
	JB ENDO1
	CMP DX,159
	JA NEXT441
		MOV DX, 3;COLUMN 3
		RET;
	NEXT441:
	CMP DX,166
	JB ENDO1
	CMP DX,199
	JA ENDO1
		MOV DX, 4;COLUMN 4
		RET;
	ENDO1:
	JMP LAVE3;
	
COMPAREDX ENDP;

EOP:
END START
CODE ENDS